"Clase previa": [[Clase 2]]

13-08-2025 - Teor√≠a con Horacio.

Cach√©:
que es, principios, jerarqu√≠as.

Perfecto, esos son justamente los pilares para responder con base s√≥lida.  
Te hago un resumen de **Cach√©: qu√© es, principios y jerarqu√≠as** citando √∫nicamente **Tanenbaum**, **Silberschatz**, y **Patterson & Hennessy**.

---

## üìå Memoria Cach√©

### **Definici√≥n**

Seg√∫n Tanenbaum (_Modern Operating Systems_, 4¬™ ed., cap. 3) y Patterson & Hennessy (_Computer Organization and Design_, 5¬™ ed., cap. 5),  
la memoria cach√© es una **memoria intermedia de alta velocidad** situada entre la CPU y la memoria principal, destinada a **reducir el tiempo promedio de acceso a datos e instrucciones**.

El principio es aprovechar la **localidad de referencia**:

- **Localidad temporal**: si un dato se usa, probablemente se vuelva a usar pronto.
    
- **Localidad espacial**: si se accede a una posici√≥n de memoria, es probable que las adyacentes tambi√©n se usen pronto.
    

---

### **Principios de funcionamiento**

> (Basado en Silberschatz _Operating System Concepts_, 10¬™ ed., cap. 9, y Patterson & Hennessy, cap. 5)

1. **Jerarqu√≠a de memoria**: la cach√© es m√°s peque√±a pero m√°s r√°pida que la RAM, y almacena copias de bloques de memoria.
    
2. **Mapeo de bloques**:
    
    - **Directo**: cada bloque de memoria principal va a una posici√≥n espec√≠fica en cach√©.
        
    - **Asociativo**: cualquier bloque puede ir a cualquier l√≠nea de cach√©.
        
    - **Asociativo por conjunto**: h√≠brido entre los dos anteriores.
        
3. **Pol√≠ticas de reemplazo**: deciden qu√© bloque expulsar cuando la cach√© est√° llena (ej.: LRU ‚Äî _Least Recently Used_, FIFO, Random).
    
4. **Pol√≠ticas de escritura**:
    
    - **Write-through**: escribe en memoria principal y cach√© simult√°neamente.
        
    - **Write-back**: escribe solo en cach√© y actualiza la memoria principal cuando el bloque es reemplazado.
        

---

### **Jerarqu√≠as**

> (Patterson & Hennessy, cap. 5)

- **L1**: Cach√© m√°s peque√±a y r√°pida (normalmente separada en instrucciones y datos). Latencia de 1-3 ciclos.
    
- **L2**: Mayor capacidad, algo m√°s lenta, comparte datos e instrucciones.
    
- **L3**: A√∫n m√°s grande, compartida entre n√∫cleos, pero m√°s lenta que L1 y L2.
    
- En procesadores modernos, esta jerarqu√≠a permite que la CPU mantenga un alto _throughput_ minimizando accesos a la RAM.
    

---

### **Tama√±os y gesti√≥n de p√°ginas**

Aunque la cach√© no almacena p√°ginas completas de memoria virtual, sino **bloques (l√≠neas de cach√©)** t√≠picamente de 32 a 128 bytes, su efectividad se basa en:

- Detectar qu√© datos se usan con frecuencia y mantenerlos en niveles m√°s r√°pidos.
    
- Coordinarse con la **MMU (Memory Management Unit)** y la **TLB (Translation Lookaside Buffer)** para acelerar traducciones de direcciones virtuales a f√≠sicas.
    

---

Si quer√©s, puedo hacerte el mismo resumen con **memoria virtual** y **swapping** usando √∫nicamente _Tanenbaum_, _Silberschatz_ y _Patterson & Hennessy_, as√≠ mantenemos coherencia de fuentes.7---7



---

Multiprocesador:
en un principio, eran monoprocesador.
ventajas, desventajas.
dos tipos: Asim√©trico, Sim√©trico.

Perfecto, te lo explico con base en **Tanenbaum**, **Silberschatz** y **Patterson & Hennessy**.

---

## Multiprocesadores

### 1. Contexto hist√≥rico

Seg√∫n **Tanenbaum, "Sistemas Operativos Modernos" (4ta ed.)**, los primeros computadores eran **monoprocesador**, es decir, con **una sola CPU** que ejecutaba todas las instrucciones secuencialmente.  
Con la evoluci√≥n de la tecnolog√≠a y la disminuci√≥n de costos de fabricaci√≥n de procesadores, se desarrollaron sistemas **multiprocesador** para mejorar rendimiento, tolerancia a fallos y capacidad de procesamiento paralelo.

---

### 2. Ventajas de los multiprocesadores

**Referencias:**

- Tanenbaum, _Sistemas Operativos Modernos_
    
- Silberschatz, _Operating System Concepts_
    
- Patterson & Hennessy, _Computer Organization and Design_
    
- **Mayor rendimiento**: pueden ejecutar m√∫ltiples hilos/procesos en paralelo.
    
- **Mayor disponibilidad**: si un procesador falla, otro puede asumir parte de la carga.
    
- **Mejor utilizaci√≥n de recursos**: pueden compartir memoria y perif√©ricos.
    
- **Escalabilidad**: se pueden agregar m√°s CPUs para soportar m√°s carga.
    

---

### 3. Desventajas

- **Complejidad del hardware**: requiere interconexiones r√°pidas y mecanismos de coherencia de cach√©.
    
- **Software m√°s complejo**: el sistema operativo debe coordinar y balancear la carga entre CPUs.
    
- **Problemas de concurrencia**: mayor dificultad para evitar condiciones de carrera y asegurar sincronizaci√≥n.
    
- **Costos**: m√°s procesadores implican m√°s inversi√≥n inicial y consumo energ√©tico.
    

---

### 4. Tipos de multiprocesadores

#### a) **Asim√©trico (AMP ‚Äì Asymmetric Multiprocessing)**

- **Definici√≥n** (Tanenbaum, Silberschatz): un procesador maestro controla el sistema y asigna tareas a procesadores esclavos.
    
- **Uso hist√≥rico**: com√∫n en sistemas m√°s antiguos, donde solo un CPU ejecutaba el n√∫cleo del SO y el resto hac√≠a tareas espec√≠ficas.
    
- **Ventajas**: m√°s sencillo de implementar, control centralizado.
    
- **Desventajas**: cuello de botella en el CPU maestro.
    

#### b) **Sim√©trico (SMP ‚Äì Symmetric Multiprocessing)**

- **Definici√≥n** (Patterson & Hennessy): todos los procesadores comparten la misma memoria y tienen acceso igual al sistema operativo.
    
- **Uso actual**: est√°ndar en servidores y PCs multiprocesador.
    
- **Ventajas**: todos los CPUs pueden ejecutar cualquier tarea, mejor balance de carga, sin √∫nico punto de fallo.
    
- **Desventajas**: complejidad para manejar la coherencia de cach√© y sincronizaci√≥n.
    

---

üìñ **Bibliograf√≠a exacta**:

- Tanenbaum, Andrew S. _Sistemas Operativos Modernos_, 4ta edici√≥n, Pearson, 2015. Cap. 8.
    
- Silberschatz, Abraham; Galvin, Peter; Gagne, Greg. _Operating System Concepts_, 10ma edici√≥n, Wiley, 2018. Cap. 17.
    
- Patterson, David; Hennessy, John. _Computer Organization and Design_, 5ta edici√≥n, Morgan Kaufmann, 2014. Cap. 5.
    

---

Si quer√©s, puedo pasarte un **cuadro comparativo AMP vs SMP** con ejemplos reales de cada uno, usando las referencias de estos libros para tu trabajo.

---

La idea es que simulen un monoprocesador, simule que es multi, para poder hacer varias cosas a la vez.

otros programas puedan ejecutar programas y estos usen los perif√©ricos de e/s, teniendo un mejor aprovechamiento de todos los recursos del sistema.
Paralelismo real.
economia de escala: fabricas mas grandes, producen mas barato.
des-economia de ecala: se usa mucho en software.

ejecutar rutinas de bajo nivel, de administracion.
con coordinaci√≥n, un procesador trabaja o no con otro sincronizado de alto nivel.



---

## **Multiprocesadores**

En sus inicios, la mayor√≠a de los sistemas eran **monoprocesador**, donde un √∫nico CPU se encargaba de ejecutar todas las tareas. Con el tiempo, se introdujeron **arquitecturas multiprocesador** para aumentar el rendimiento y la eficiencia.

### **Ventajas**

- **Paralelismo real**: posibilidad de ejecutar m√∫ltiples procesos de forma simult√°nea, no solo mediante multitarea simulada.
    
- **Mejor aprovechamiento de recursos**: otros programas pueden ejecutarse mientras algunos procesadores manejan tareas espec√≠ficas, incluyendo perif√©ricos de E/S.
    
- **Econom√≠a de escala**: producir procesadores en sistemas m√°s grandes reduce costos unitarios en comparaci√≥n con fabricar varias m√°quinas peque√±as.
    
- **Mayor disponibilidad**: en algunos dise√±os, la falla de un procesador no detiene todo el sistema.
    

### **Desventajas**

- **Des-econom√≠a de escala en software**: no todo software aprovecha m√∫ltiples procesadores de manera eficiente, lo que puede implicar m√°s costo de desarrollo.
    
- **Complejidad de coordinaci√≥n**: la sincronizaci√≥n y comunicaci√≥n entre procesadores requiere hardware y software m√°s sofisticado.
    
- **Contenci√≥n de recursos**: m√∫ltiples procesadores pueden competir por memoria, buses o dispositivos de E/S.
    

---

### **Tipos de Multiprocesadores**

Seg√∫n Silberschatz et al. (_Operating System Concepts_, 9th ed.) y Tanenbaum (_Modern Operating Systems_, 4th ed.), los multiprocesadores se dividen principalmente en:

1. **Asim√©tricos (AMP)**
    
    - Un procesador maestro controla la asignaci√≥n de tareas y la comunicaci√≥n con el sistema operativo.
        
    - Los dem√°s procesadores ejecutan √∫nicamente tareas asignadas por el maestro.
        
    - M√°s simple de implementar, pero con riesgo de cuello de botella en el procesador maestro.
        
2. **Sim√©tricos (SMP)**
    
    - Todos los procesadores son iguales y ejecutan el sistema operativo de forma concurrente.
        
    - Cualquier procesador puede ejecutar cualquier tarea o rutina, incluyendo administraci√≥n de recursos.
        
    - Mejor distribuci√≥n de carga, pero mayor complejidad de sincronizaci√≥n.
        

---

### **Objetivo del Dise√±o**

- **Simular un monoprocesador**, pero con capacidad real de procesamiento paralelo.
    
- Permitir que varios programas compartan recursos de E/S de forma eficiente.
    
- Ejecuci√≥n de **rutinas de bajo nivel** (administraci√≥n) por un procesador mientras otros ejecutan aplicaciones de usuario.
    
- Coordinaci√≥n opcional: algunos procesadores pueden trabajar de forma independiente, o bien sincronizarse en tareas de alto nivel.
    

---

**Referencias bibliogr√°ficas:**

- Tanenbaum, A. S., & Bos, H. (2015). _Modern Operating Systems_ (4th ed.). Pearson.
    
- Silberschatz, A., Galvin, P. B., & Gagne, G. (2018). _Operating System Concepts_ (9th ed.). Wiley.
    
- Patterson, D. A., & Hennessy, J. L. (2017). _Computer Organization and Design: The Hardware/Software Interface_ (5th ed.). Morgan Kaufmann.
    

---

Si quer√©s, puedo ahora hacerte el **esquema comparativo** entre monoprocesador y multiprocesador para que lo tengas en formato de tabla resumida.

---

Cpu con sus propios registros
clusters

nodos, con sus memorias y procesadores(en clusters)
en un programa concurrente, puede terminar un thred de un nodo, y otro en otro procesador de otro modo. sincronizando los threds.
funciona porque, un programa distribuido en un sistema de cluster, se puede romper un modulo entero pero anda igual. se puede relentizar un poco pero sigue andando.
SAN= Storage-Area-Network
Cluster, como armar uno, como funciona, para que es, beneficios.

Perfecto, con lo que me pasaste puedo armarte una explicaci√≥n completa y ordenada sobre **multiprocesadores** y **clusters**, integrando las ideas que escribiste.

---

## **Multiprocesadores**

### 1. Introducci√≥n

En sus inicios, los sistemas eran **monoprocesador**, es decir, una √∫nica CPU realizaba todas las tareas del sistema, ejecutando instrucciones de manera secuencial.  
Con el tiempo, para mejorar el rendimiento, se desarrollaron los **multiprocesadores**, que permiten ejecutar varios procesos o hilos al mismo tiempo.

---

### 2. Ventajas

- **Paralelismo real**: posibilidad de ejecutar varias tareas a la vez, no solo simular multitarea.
    
- **Mejor aprovechamiento de recursos**: varios programas pueden usar la CPU y los perif√©ricos en paralelo.
    
- **Mayor rendimiento** en tareas intensivas en c√≥mputo.
    
- **Econom√≠a de escala**: producir procesadores con m√°s n√∫cleos resulta m√°s barato que producir varias m√°quinas separadas.
    

---

### 3. Desventajas

- **Des-econom√≠a de escala en software**: desarrollar aplicaciones que aprovechen m√∫ltiples procesadores es m√°s complejo y costoso.
    
- **Coordinaci√≥n y sincronizaci√≥n**: se necesita control para que los procesadores trabajen sin conflictos.
    
- **Posibles cuellos de botella** en memoria y buses si no est√°n bien dise√±ados.
    

---

### 4. Tipos de Multiprocesadores

- **Asim√©trico (AMP)**
    
    - Un procesador principal coordina y asigna trabajo a procesadores secundarios.
        
    - Los secundarios pueden estar dedicados a tareas espec√≠ficas (por ejemplo, manejo de E/S).
        
    - Simplicidad en control, pero menos flexible.
        
- **Sim√©trico (SMP)**
    
    - Todos los procesadores son iguales y comparten la misma memoria.
        
    - Pueden ejecutar cualquier tarea.
        
    - Mayor flexibilidad, pero requiere m√°s complejidad en sincronizaci√≥n.
        

---

## **Clusters**

### 1. Concepto

Un **cluster** es un conjunto de computadoras (nodos) que trabajan juntas como si fueran un √∫nico sistema.  
Cada nodo tiene:

- Su propia CPU y registros.
    
- Su propia memoria.
    
- Sus propios dispositivos de almacenamiento o conexi√≥n a una red de almacenamiento (**SAN**, _Storage Area Network_).
    

---

### 2. Funcionamiento

- Los nodos est√°n conectados por una red de alta velocidad.
    
- El sistema distribuye la carga de trabajo entre los nodos.
    
- En programas concurrentes, un hilo (thread) puede ejecutarse en un nodo y otro hilo en otro nodo distinto.
    
- Si un nodo falla, el resto sigue trabajando (**tolerancia a fallos**), aunque puede reducirse la velocidad.
    

---

### 3. Beneficios

- **Escalabilidad**: se pueden agregar m√°s nodos para aumentar la capacidad de c√≥mputo.
    
- **Tolerancia a fallos**: un fallo en un nodo no detiene todo el sistema.
    
- **Costos optimizados**: se pueden usar servidores est√°ndar conectados.
    
- **Alto rendimiento**: ideal para computaci√≥n cient√≠fica, bases de datos distribuidas, big data, etc.
    

---

### 4. C√≥mo armar un cluster

1. **Hardware**: varios servidores o PCs con conexi√≥n de red r√°pida.
    
2. **Almacenamiento**: opcionalmente, una SAN para que todos accedan a los mismos datos.
    
3. **Software de cluster**: gestiona la distribuci√≥n de tareas y la sincronizaci√≥n (ej.: Kubernetes, Hadoop, OpenMPI, Pacemaker).
    
4. **Configuraci√≥n**: definir pol√≠ticas de balanceo de carga y failover.
    

---


como funciona la memoria virtual

memoria principal + memoria virtual

memoria secundaria + memoria virtual mas grande

Como funciona para que sirva?

La **memoria virtual** funciona como una especie de "ilusi√≥n controlada" que le da al sistema operativo la capacidad de hacerle creer a los programas que tienen a su disposici√≥n una memoria RAM m√°s grande, continua y privada de lo que realmente existe f√≠sicamente.

Voy a desglosarlo en c√≥mo funciona y para qu√© sirve:

---

## **1. C√≥mo funciona la memoria virtual**

La memoria virtual combina **memoria principal (RAM)** y **memoria secundaria (disco duro o SSD)** para dar una visi√≥n unificada al procesador.

### üîπ Paso a paso:

1. **Espacio de direcciones virtuales**
    
    - Cada proceso cree que tiene su propio espacio de memoria que empieza en la direcci√≥n 0 y puede llegar a un l√≠mite muy grande (por ejemplo, 4 GB en sistemas de 32 bits o much√≠simo m√°s en 64 bits).
        
    - Estas direcciones son **virtuales**, no coinciden con la RAM f√≠sica real.
        
2. **Paginaci√≥n (Paging)**
    
    - El sistema divide la memoria en bloques llamados **p√°ginas** (t√≠picamente de 4 KB).
        
    - Cada p√°gina virtual puede estar:
        
        - En **RAM f√≠sica** (r√°pido acceso)
            
        - O en **almacenamiento secundario** (archivo de intercambio o _swap_).
            
3. **MMU (Unidad de Gesti√≥n de Memoria)**
    
    - Hardware que traduce direcciones virtuales a direcciones f√≠sicas usando una **tabla de p√°ginas**.
        
    - Si la p√°gina que necesita el programa no est√° en RAM, ocurre un **page fault**.
        
4. **Intercambio (Swapping)**
    
    - Cuando hay un _page fault_, el sistema trae la p√°gina requerida desde el disco a la RAM, y si es necesario, guarda una p√°gina menos usada de la RAM al disco (_swap out_).
        

---

## **2. Para qu√© sirve**

- **Aumentar el espacio de memoria disponible**  
    Permite ejecutar programas m√°s grandes que la RAM f√≠sica.
    
- **Aislar procesos**  
    Un programa no puede acceder directamente a la memoria de otro, lo que aumenta la seguridad y estabilidad.
    
- **Protecci√≥n de memoria**  
    Evita que un error en un programa corrompa la memoria de todo el sistema.
    
- **Eficiencia**  
    Se cargan en RAM solo las partes del programa que realmente se usan (_carga bajo demanda_).
    
- **Multiprogramaci√≥n**  
    Permite que m√∫ltiples procesos coexistan en la RAM, con parte de sus datos en disco.
    

---

üìå **Ejemplo simple**  
Imagina que tu computadora tiene **8 GB de RAM** pero el sistema operativo permite que los programas crean que hay **32 GB** gracias a que usa **24 GB de espacio en disco** como _swap_.  
Esto funciona bien mientras el sistema no abuse del disco, porque el disco es **miles de veces m√°s lento** que la RAM.

---

Si quieres, te puedo hacer un **diagrama visual** que muestre el flujo: _direcci√≥n virtual ‚Üí tabla de p√°ginas ‚Üí RAM ‚Üí swap_.  
As√≠ quedar√≠a muy claro c√≥mo interact√∫a todo.

La **memoria virtual** es una t√©cnica que usa el sistema operativo para simular que hay m√°s memoria RAM de la que f√≠sicamente existe, combinando la **memoria principal (RAM)** con parte de la **memoria secundaria** (normalmente el disco duro o SSD).

---

## üìå ¬øQu√© es exactamente?

Es una **abstracci√≥n** que permite que cada programa crea que tiene a su disposici√≥n un espacio de direcciones de memoria continuo y muy grande, aunque f√≠sicamente:

- La RAM sea m√°s peque√±a.
    
- Los datos est√©n repartidos entre RAM y disco.
    

---

## ‚öôÔ∏è ¬øC√≥mo funciona?

1. **Direcciones l√≥gicas vs f√≠sicas**
    
    - El programa no trabaja con direcciones reales de memoria, sino con **direcciones virtuales**.
        
    - El sistema operativo y la **MMU** (Unidad de Gesti√≥n de Memoria) las traducen a direcciones f√≠sicas reales.
        
2. **Paginaci√≥n o segmentaci√≥n**
    
    - La memoria virtual se divide en **p√°ginas** (bloques de tama√±o fijo, por ejemplo 4 KB).
        
    - Cuando una p√°gina no est√° en RAM, se guarda en un **archivo de intercambio** (_swap file_ o _pagefile_) en el disco.
        
3. **Carga bajo demanda**
    
    - Si un programa necesita datos que est√°n en disco, el sistema operativo los trae a la RAM (esto se llama **page fault**).
        
4. **Liberaci√≥n de RAM**
    
    - Si la RAM se llena, p√°ginas menos usadas se env√≠an al disco para liberar espacio para otras.
        

---

## üéØ ¬øPara qu√© sirve?

- **Ejecutar programas m√°s grandes** que la memoria f√≠sica disponible.
    
- **Tener m√°s programas abiertos** al mismo tiempo sin que el sistema se quede sin RAM.
    
- **Aislar procesos**: cada uno cree que tiene su propio espacio de memoria.
    
- **Protecci√≥n de memoria**: evita que un programa interfiera con otro o con el sistema operativo.
    

---

üí° Ejemplo r√°pido:  
Si tienes **8 GB de RAM** y activas memoria virtual con **16 GB de swap**, el sistema podr√≠a manejar **hasta 24 GB de direcciones virtuales** (aunque la parte que est√° en disco ser√° m√°s lenta que la RAM).

---

interrupciones
Interrupciones (software) = exceptions o traps
instrucciones (privilegiadas) s√≥lo pueden ser ejecutadas en modo privilegiado.
todo procesador, tiene un bit de modo. modo root, supervisor, privilegiado, y si esta en 0 esta en modo usuario.


---

## **Interrupciones**

Son se√±ales que **alteran el flujo normal de ejecuci√≥n** de un procesador para que atienda un evento espec√≠fico.  
Al ocurrir, el CPU **detiene** la ejecuci√≥n actual, guarda el estado y salta a una **rutina de servicio** para manejar ese evento.

---

### **Tipos principales**

1. **Interrupciones de hardware**
    
    - Provienen de dispositivos externos al procesador.
        
    - Ejemplos:
        
        - Teclado presionado.
            
        - Llega un paquete de red.
            
        - Fin de lectura/escritura de disco.
            
    - As√≠ncronas respecto al CPU.
        
2. **Interrupciones de software**
    
    - Generadas por el propio CPU o por instrucciones especiales.
        
    - Dos subtipos importantes:
        
        - **Exceptions** ‚Üí Ocurren cuando algo sale mal durante la ejecuci√≥n (ej. divisi√≥n por cero, acceso inv√°lido a memoria).
            
        - **Traps** ‚Üí Usadas para llamar expl√≠citamente a rutinas del sistema operativo (ej. llamadas al sistema, `syscall`).
            
    - Son s√≠ncronas respecto a la ejecuci√≥n del programa.
        

---

## **Instrucciones privilegiadas**

- Son instrucciones que **solo el sistema operativo** puede ejecutar.
    
- Ejemplos:
    
    - Configurar la MMU (unidad de gesti√≥n de memoria).
        
    - Cambiar registros de control.
        
    - Apagar o reiniciar el sistema.
        
- La raz√≥n es **seguridad y estabilidad**: si un programa de usuario pudiera usarlas libremente, podr√≠a bloquear el sistema o acceder a recursos no autorizados.
    

---

## **Modos del procesador**

El procesador tiene **al menos dos modos** para distinguir si est√° ejecutando c√≥digo del sistema operativo o de usuario:

|**Modo**|**Bit de Modo**|**Nombre com√∫n**|**Acceso**|
|---|---|---|---|
|Privilegiado|1 (o ON)|_Kernel mode_, _supervisor mode_, _root mode_|Puede ejecutar **todas** las instrucciones (incluyendo privilegiadas).|
|Usuario|0 (o OFF)|_User mode_|Puede ejecutar **solo** instrucciones seguras. Las privilegiadas generan una excepci√≥n.|

---

## **Ciclo t√≠pico con interrupci√≥n**

1. CPU ejecuta instrucciones en modo usuario.
    
2. Ocurre una **interrupci√≥n** (hardware) o **trap** (software).
    
3. El CPU:
    
    - Guarda el estado actual (program counter, registros).
        
    - Cambia a **modo privilegiado**.
        
    - Salta a la rutina de manejo correspondiente.
        
4. El sistema operativo atiende la interrupci√≥n.
    
5. Se restaura el estado y se vuelve al modo usuario.
    

---

üí° En resumen:

- Las **interrupciones** permiten al CPU responder a eventos sin estar verificando constantemente si pasaron.
    
- Los **modos de operaci√≥n** son un mecanismo de seguridad para que solo el SO maneje recursos cr√≠ticos.
    
- Las **instrucciones privilegiadas** son las herramientas que solo el kernel puede usar.
    

---

repertorio del cpu, tiene asociada a si mismas, cada una de ellas, el modo que las permite.
hay algunas que es para ambas, pero otras solo se ejecutan en un modo especifico.

en una primera instancia, podemos decir que las instrucciones que ejecuta el sistema op corren en sistemas privilegiados, el procesador tiene que tener el bit de modo en privilegiado, sino, esta en modo usuario, y el usuario quiere usar una que es privilegiada, deber√≠a darte error. para admitir la ejecuci√≥n de la instrucci√≥n.


Exacto, lo que describes es el mecanismo de **protecci√≥n de modos del CPU** para garantizar que un usuario o programa no pueda ejecutar instrucciones cr√≠ticas sin pasar por el sistema operativo.

Te lo explico ordenado:

---

### **1. Modos de ejecuci√≥n del CPU**

- **Modo privilegiado / supervisor / kernel**:  
    Permite ejecutar **todas** las instrucciones, incluidas las **privilegiadas** (acceso directo a hardware, control de interrupciones, manejo de memoria, etc.).
    
- **Modo usuario**:  
    S√≥lo permite ejecutar instrucciones seguras. Si intenta ejecutar una instrucci√≥n privilegiada ‚Üí genera **trampa (trap)** o **exception**, y el control pasa al sistema operativo.
    

El **bit de modo** en el registro de estado del procesador indica en qu√© modo est√°:

- `1` ‚Üí Modo kernel (privilegiado)
    
- `0` ‚Üí Modo usuario (no privilegiado)  
    _(El valor exacto puede variar seg√∫n la arquitectura, pero la idea es esa.)_
    

---

### **2. Repertorio de instrucciones y privilegios**

Cada instrucci√≥n en el set del CPU tiene un nivel:

- **Instrucciones para ambos modos**: operaciones aritm√©ticas, l√≥gicas, carga/almacenamiento de datos en memoria de usuario, saltos, etc.
    
- **Instrucciones privilegiadas**: manipular registros de control, cambiar mapeo de memoria virtual, habilitar/deshabilitar interrupciones, acceso directo a dispositivos de E/S.
    

---

### **3. Ejecuci√≥n de instrucciones privilegiadas**

1. El CPU est√° en **modo usuario**.
    
2. El programa intenta ejecutar una instrucci√≥n privilegiada.
    
3. El **hardware del CPU** detecta que el bit de modo ‚â† privilegiado.
    
4. Genera **exception** ‚Üí salta al sistema operativo.
    
5. El SO decide si la instrucci√≥n se permite (por ejemplo, a trav√©s de una llamada al sistema) o se deniega.
    

---

üí° En resumen:  
Esto es una medida de **seguridad y estabilidad**. Sin ella, cualquier programa podr√≠a:

- Apagar el sistema.
    
- Reescribir memoria de otro proceso.
    
- Manipular el hardware directamente.
    

---

Algunas funciones del SO:

‚óèAdministraci√≥n de procesos (programas en ejecuci√≥n)
‚óèAdministraci√≥n de la memoria principal
‚óèAdministraci√≥n del almacenamiento secundario
‚óèAdministraci√≥n del subsistema de E/S
‚óèProtecci√≥n y seguridad

Perfecto, te hago un resumen ordenado y con un poco m√°s de detalle, basado en **Tanenbaum**, **Silberschatz** y **Patterson & Hennessy**:

---

## **Funciones del Sistema Operativo (SO)**

El **sistema operativo** act√∫a como intermediario entre el hardware y los programas de usuario, gestionando los recursos del sistema y proporcionando servicios esenciales.

---

### 1. **Administraci√≥n de procesos**

- Gestiona la **creaci√≥n, ejecuci√≥n y finalizaci√≥n** de procesos.
    
- Implementa **planificaci√≥n (scheduling)** para decidir qu√© proceso se ejecuta y por cu√°nto tiempo.
    
- Maneja la **concurrencia** y la sincronizaci√≥n de procesos o hilos.
    

> _Referencia:_ Silberschatz, Galvin & Gagne, _Operating System Concepts_, Cap. 3.

---

### 2. **Administraci√≥n de memoria principal**

- Controla el **asignamiento de memoria a procesos**.
    
- Implementa **memoria virtual**, **paginaci√≥n** y **segmentaci√≥n** para optimizar el uso de la RAM.
    
- Protege a los procesos unos de otros mediante l√≠mites de memoria.
    

> _Referencia:_ Tanenbaum, _Modern Operating Systems_, Cap. 3.  
> _Referencia:_ Patterson & Hennessy, _Computer Organization and Design_, Cap. 5.

---

### 3. **Administraci√≥n del almacenamiento secundario**

- Maneja discos, SSD y otros dispositivos de almacenamiento.
    
- Se encarga de **sistemas de archivos**, directorios, lectura/escritura de bloques y control de acceso.
    
- Implementa **pol√≠ticas de almacenamiento y cache de disco** para mejorar el rendimiento.
    

> _Referencia:_ Silberschatz, Cap. 11.

---

### 4. **Administraci√≥n del subsistema de E/S**

- Coordina la comunicaci√≥n entre **dispositivos de entrada/salida** y la CPU.
    
- Utiliza **buffers**, **colas** y controladores de dispositivos.
    
- Puede emplear **DMA (Direct Memory Access)** para mejorar la eficiencia de transferencias sin intervenci√≥n constante del CPU.
    

> _Referencia:_ Tanenbaum, Cap. 5.

---

### 5. **Protecci√≥n y seguridad**

- Garantiza que **un proceso no interfiera con otro** ni acceda a recursos sin autorizaci√≥n.
    
- Controla permisos de archivos, memoria y dispositivos.
    
- Administra **usuarios, autenticaci√≥n y privilegios**.
    

> _Referencia:_ Silberschatz, Cap. 14.

---

En resumen, el SO **orquesta todos los recursos del sistema** para que m√∫ltiples programas puedan ejecutarse de manera segura y eficiente, aprovechando al m√°ximo el hardware disponible.

---

Los procesos requieren recursos para realizar lo que deben realizar
La terminaci√≥n de un proceso debe permitir recuperar los recursos reusables.
recursos reusables, y recursos que no.

Exacto, esto forma parte de la **gesti√≥n de recursos** en un sistema operativo. Te lo explico con detalle y referencias:

---

## **Recursos en un sistema operativo**

Un **proceso** necesita distintos **recursos** para ejecutarse correctamente, como CPU, memoria, dispositivos de E/S o archivos.  
El SO se encarga de **asignar**, **controlar** y **recuperar** esos recursos de manera eficiente.

---

### 1. **Tipos de recursos seg√∫n reutilizaci√≥n**

#### a) **Recursos reutilizables**

- Son recursos que **no se consumen al usarse**, sino que pueden volver a ser utilizados por otros procesos despu√©s de ser liberados.
    
- Ejemplos:
    
    - **CPU**: un proceso la usa durante su ejecuci√≥n, luego otro proceso puede usarla.
        
    - **Memoria principal**: despu√©s de terminar el proceso, la memoria se libera para otros procesos.
        
    - **Dispositivos de E/S**: impresoras, discos, etc., pueden ser usados por varios procesos, pero solo uno a la vez.
        
- Gesti√≥n t√≠pica: **asignaci√≥n din√°mica**, **colas de espera**, **se√±ales de disponibilidad**.
    

> _Referencia:_ Silberschatz, Galvin & Gagne, _Operating System Concepts_, 10th ed., Cap. 6.

#### b) **Recursos consumibles o no reutilizables**

- Son recursos que se **agotan al usarse** y no pueden recuperarse para otro proceso.
    
- Ejemplos:
    
    - Archivos temporales que se eliminan tras su uso.
        
    - Tokens o cr√©ditos contables que representan unidades limitadas de algo.
        
    - Algunos tipos de datos de un flujo de informaci√≥n que se consumen al ser le√≠dos.
        
- Gesti√≥n t√≠pica: **control de acceso estricto**, **seguimiento de consumo**.
    

> _Referencia:_ Tanenbaum, _Modern Operating Systems_, 4th ed., Cap. 3.

---

### 2. **Recuperaci√≥n de recursos**

Cuando un proceso termina:

- El SO debe liberar **todos los recursos reutilizables** asignados a ese proceso.
    
- Para los recursos consumibles, simplemente se da por hecho que **ya se consumieron** y no pueden reutilizarse.
    
- Esto evita **fugas de recursos** (_resource leaks_) y mantiene el sistema estable.
    

---

cuando el sistema operativo tiene que administrar:

‚óè Crear y eliminar procesos del usuario y del sistema
‚óè Suspender y rehabilitar procesos
‚óè Suministrar mecanismos para la sincronizaci√≥n de procesos
‚óè Suministrar mecanismos para la comunicaci√≥n entre procesos
‚óè Suministrar mecanismos para el manejo de interbloqueo (deadlock)

controlador, ya es un software, pero para el pendrive necesita otro controlador, es software.
mas arriba me dan mas
abrir dispositivo A usa el archivo tal y cerrar el dispositivo.
normalmente guardo datos, en forma de archivos.

Administraci√≥n del Almacenamiento

‚óèEl SO debe suministrar una visi√≥n l√≥gica uniforme del
almacenamiento

‚óèOcultar caracter√≠sticas f√≠sicas y mostrar unidades l√≥gicas-de almacenamiento (files)

‚óèLos medios de almacenamiento son muy diversos, con
propiedades distintas

‚óèAdministraci√≥n de archivos (files)

‚óèUsualmente organizados en directorios

‚óèDebe determinarse quien puede acceder y para qu√©

‚óèLas actividades del SO incluyen

‚óèCrear y borrar archivos y directorios

‚óèSuministrar primitivas para manipular archivos y directorios

‚óèMapear los archivos en la memoria secundaria

Perfecto, voy a organizar toda esa informaci√≥n en un **resumen claro sobre la administraci√≥n de procesos y de almacenamiento** seg√∫n los conceptos de **Tanenbaum** y **Silberschatz**, usando el lenguaje acad√©mico t√≠pico de sistemas operativos.

---

## **Administraci√≥n de Procesos**

El **sistema operativo (SO)** es responsable de gestionar los **procesos**, tanto de usuario como del propio sistema, asegurando que los recursos se usen de forma eficiente y segura.

### Funciones principales:

1. **Creaci√≥n y eliminaci√≥n de procesos**
    
    - El SO puede iniciar procesos nuevos seg√∫n solicitudes del usuario o del sistema.
        
    - Al finalizar un proceso, el SO debe liberar los recursos que el proceso utiliz√≥.
        
2. **Suspender y reanudar procesos**
    
    - Permite **detener temporalmente** un proceso para liberar CPU o recursos y **reanudarlo** posteriormente.
        
3. **Sincronizaci√≥n de procesos**
    
    - Proporciona mecanismos para coordinar procesos que **comparten recursos**, evitando conflictos y condiciones de carrera.
        
4. **Comunicaci√≥n entre procesos**
    
    - Incluye **pipes, colas de mensajes, memoria compartida**, etc., para que los procesos intercambien informaci√≥n de manera segura.
        
5. **Manejo de interbloqueo (deadlock)**
    
    - Detecta y evita situaciones donde dos o m√°s procesos quedan **bloqueados esperando recursos mutuamente**.
        

> _Referencia:_ Silberschatz, Galvin & Gagne, _Operating System Concepts_, 10th ed., Cap. 3‚Äì6.  
> _Referencia:_ Tanenbaum, _Modern Operating Systems_, 4th ed., Cap. 3‚Äì4.

---

## **Administraci√≥n del Almacenamiento Secundario**

El SO debe proporcionar una **visi√≥n l√≥gica uniforme** del almacenamiento, ocultando la complejidad del hardware y facilitando la gesti√≥n de datos.

### Principales funciones:

1. **Organizaci√≥n de almacenamiento**
    
    - Oculta la **estructura f√≠sica** de los dispositivos (sectores, pistas, cilindros).
        
    - Presenta **unidades l√≥gicas**, los archivos (_files_), que son manipulables por los usuarios y programas.
        
2. **Administraci√≥n de archivos y directorios**
    
    - Crear, borrar y manipular archivos y directorios.
        
    - Organizar archivos en **jerarqu√≠as l√≥gicas** (directorios y subdirectorios).
        
    - Determinar **permisos de acceso**: qui√©n puede leer, escribir o ejecutar.
        
3. **Mapeo en memoria secundaria**
    
    - Asocia los archivos a **espacios f√≠sicos en disco o almacenamiento externo**.
        
    - Permite al SO usar t√©cnicas de **caching y buffering** para mejorar el rendimiento.
        
4. **Gesti√≥n de dispositivos**
    
    - Cada dispositivo (pendrive, disco, impresora) tiene un **controlador espec√≠fico** (software).
        
    - Operaciones t√≠picas:
        
        - Abrir el dispositivo ‚Üí abrir el archivo o recurso correspondiente.
            
        - Leer/escribir datos ‚Üí manipulaci√≥n de los bloques f√≠sicos mediante el controlador.
            
        - Cerrar el dispositivo ‚Üí liberar recursos.
            

> _Referencia:_ Silberschatz et al., Cap. 11‚Äì12.  
> _Referencia:_ Tanenbaum, Cap. 5.

---

para hacer un uso mas eficiente, del recurso al dispositivo perif√©rico
por eso es importante buscar el eso

buen rendimiento, uso eficiente del uso de almacenamiento masivo.
lo que hago es, llegan los requerimientos y pongo los procesos en una lista.
planificaci√≥n. de acuerdo a las pol√≠ticas de orden.

Exacto, lo que est√°s describiendo corresponde a la **planificaci√≥n de recursos y de dispositivos de E/S** en un sistema operativo, que busca **maximizar eficiencia y rendimiento**. Te lo explico ordenadamente y con referencias:

---

## **Administraci√≥n de Dispositivos y Planificaci√≥n de E/S**

### 1. **Objetivo**

El SO gestiona dispositivos de E/S (discos, impresoras, redes, etc.) para que varios procesos puedan compartirlos de manera eficiente y sin conflictos.

- Garantiza **uso √≥ptimo de recursos**.
    
- Mejora **rendimiento general** del sistema.
    
- Evita que procesos se bloqueen innecesariamente.
    

---

### 2. **C√≥mo se logra**

1. **Colas de solicitudes**
    
    - Las peticiones de E/S de todos los procesos se colocan en **listas o colas**.
        
    - Cada solicitud espera su turno seg√∫n la pol√≠tica de planificaci√≥n.
        
2. **Pol√≠ticas de planificaci√≥n**
    
    - **FIFO (First-In-First-Out)**: atiende solicitudes en orden de llegada.
        
    - **SSTF (Shortest Seek Time First)**: da prioridad a la solicitud m√°s cercana en disco (minimiza tiempo de b√∫squeda).
        
    - **SCAN / C-SCAN**: el cabezal del disco recorre en una direcci√≥n atendiendo solicitudes y luego regresa.
        
    - **Prioridades**: algunas solicitudes cr√≠ticas pueden adelantarse a otras.
        
3. **Buffers y caching**
    
    - Se utilizan **buffers** para almacenar temporalmente los datos que van hacia o desde el dispositivo.
        
    - Permite que el CPU y los procesos no esperen a que termine la operaci√≥n f√≠sica.
        
4. **Objetivo final**
    
    - **Eficiencia del dispositivo**: que el hardware trabaje lo menos posible en vac√≠o.
        
    - **Equidad**: que todos los procesos tengan acceso a los dispositivos.
        
    - **Rendimiento del sistema**: menor tiempo de respuesta y mayor throughput.
        

---

### 3. **Referencias**

- Silberschatz, Galvin & Gagne, _Operating System Concepts_, Cap. 11‚Äì12.
    
- Tanenbaum, _Modern Operating Systems_, Cap. 5.
    
- Patterson & Hennessy, _Computer Organization and Design_, Cap. 5 (para acceso a discos y E/S).
    

---

Planificaci√≥n de disco.
con una capa de soft, toma todos los requerimiento, planifica y aplica. para resolver todos los requerimientos.

Exacto, lo que est√°s describiendo es la **planificaci√≥n de disco** (_disk scheduling_) en un sistema operativo. Te lo resumo de forma organizada y con referencias:

---

## **Planificaci√≥n de Disco**

### 1. **Concepto**

- Los discos son **dispositivos de almacenamiento relativamente lentos** comparados con la CPU y la RAM.
    
- Para mejorar eficiencia, el SO utiliza una **capa de software** que:
    
    1. Recibe **todos los requerimientos de lectura/escritura** de los procesos.
        
    2. Los organiza seg√∫n **pol√≠ticas de planificaci√≥n**.
        
    3. Ejecuta los requerimientos de manera **optimizada**, reduciendo tiempo de b√∫squeda y esperando lo menos posible.
        

> _Referencia:_ Silberschatz, Galvin & Gagne, _Operating System Concepts_, Cap. 11.  
> _Referencia:_ Tanenbaum, _Modern Operating Systems_, Cap. 5.

---

### 2. **Funcionamiento**

1. **Recepci√≥n de solicitudes**
    
    - Todos los procesos que necesitan acceder al disco generan **peticiones de E/S**.
        
    - Estas solicitudes se colocan en una **cola de disco**.
        
2. **Planificaci√≥n**
    
    - El **software del SO** analiza la cola y decide el **orden de ejecuci√≥n** seg√∫n la pol√≠tica elegida.
        
    - Ejemplos de pol√≠ticas:
        
        - **FIFO (First-In-First-Out)**: atender en orden de llegada.
            
        - **SSTF (Shortest Seek Time First)**: atender la solicitud m√°s cercana al cabezal.
            
        - **SCAN / C-SCAN**: el cabezal recorre el disco de un extremo al otro, atendiendo solicitudes en el camino.
            
        - **Prioridad**: solicitudes cr√≠ticas se atienden antes que otras.
            
3. **Aplicaci√≥n de las solicitudes**
    
    - El SO env√≠a las √≥rdenes al **controlador del disco**, que realiza la operaci√≥n f√≠sica de lectura/escritura.
        
    - El **buffer** permite que la CPU y el proceso no tengan que esperar a que la operaci√≥n f√≠sica termine.
        

---

### 3. **Objetivo**

- **Maximizar eficiencia del disco**: minimizar movimientos del cabezal y tiempos de espera.
    
- **Equidad**: que todos los procesos puedan acceder al disco.
    
- **Mejor rendimiento del sistema**: menor tiempo de respuesta y mayor throughput.
    

---

Subsistema de I/O
Administrar la memoria de I/O

	Buffering: almacenamiento temporario de datos mientras est√°n siendo transferidos
	Caching: almacenamiento temporario de datos en un almacenamiento m√°s r√°pido
	Spooling: simulacion de perifericos en linea.
	Suministrar drivers para dispositivos espec√≠ficos

Perfecto, podemos organizar toda esta informaci√≥n dentro del concepto de **Subsistema de E/S (I/O)** seg√∫n la literatura de Tanenbaum y Silberschatz:

---

## **Subsistema de Entrada/Salida (I/O)**

El **subsistema de I/O** del sistema operativo se encarga de **administrar la comunicaci√≥n entre los procesos y los dispositivos perif√©ricos**, de manera eficiente y segura. Esto incluye la **gesti√≥n de memoria de I/O**, controladores y mecanismos de optimizaci√≥n.

---

### 1. **Administraci√≥n de la memoria de I/O**

Para optimizar la transferencia de datos entre **CPU y dispositivos**, se utilizan varias t√©cnicas:

#### a) **Buffering**

- Almacena temporalmente los datos en memoria mientras se transfieren entre el dispositivo y la CPU.
    
- Permite que los procesos contin√∫en ejecut√°ndose sin esperar a que el dispositivo complete la operaci√≥n.
    
- Ejemplo: almacenar temporalmente datos que se van a imprimir.
    

> _Referencia:_ Tanenbaum, _Modern Operating Systems_, Cap. 5.

#### b) **Caching**

- Almacena temporalmente los datos en un **almacenamiento m√°s r√°pido**, t√≠picamente RAM, para acelerar futuras operaciones.
    
- Evita accesos repetidos a dispositivos lentos como discos.
    
- Ejemplo: almacenar bloques de disco le√≠dos recientemente en memoria.
    

> _Referencia:_ Silberschatz et al., _Operating System Concepts_, Cap. 11.

#### c) **Spooling**

- Simula dispositivos en l√≠nea mediante **colocaci√≥n de trabajos en una cola** para su ejecuci√≥n posterior.
    
- Muy usado en impresoras: los trabajos se almacenan en disco y se procesan en orden sin bloquear a los programas que los enviaron.
    

> _Referencia:_ Tanenbaum, Cap. 5.

---

### 2. **Drivers de dispositivos**

- Cada dispositivo (pendrive, disco, impresora, tarjeta de red) tiene un **driver espec√≠fico**: un m√≥dulo de software que traduce las solicitudes gen√©ricas del SO en comandos que el dispositivo puede entender.
    
- El SO suministra una **interfaz uniforme**, de modo que los programas **no necesiten conocer la implementaci√≥n f√≠sica** del dispositivo.
    

---

### 3. **Objetivos del Subsistema de I/O**

- Optimizar el **rendimiento de los dispositivos**.
    
- Permitir **concurrencia**: varios procesos pueden solicitar E/S sin bloquearse mutuamente.
    
- Abstraer la **heterogeneidad de hardware**, ofreciendo una visi√≥n uniforme al resto del sistema.
    

---

Protecci√≥n: cualquier mecanismo que controle el acceso de procesos o usuarios a los recursos
‚óè Seguridad: defensa del sistema contra ataques internos y externos
‚óè Los SO deben distinguir entre usuarios para determinar qui√©n puede hacer qu√©
‚óè Identificaci√≥n de usuarios (user IDs)
‚óè Asociaci√≥n del user ID con archivos y procesos para determinar el control de acceso
‚óè Identificaci√≥n de grupos

protecci√≥n que nadie acceda a donde no se debe acceder.
seguridad, que un ataque no rompa algo indebido.



---

## **Protecci√≥n y Seguridad en Sistemas Operativos**

El SO debe garantizar que los recursos del sistema se utilicen de manera **segura y controlada**, distinguiendo entre **protecci√≥n** y **seguridad**.

---

### 1. **Protecci√≥n**

- Es cualquier **mecanismo que controla el acceso de procesos o usuarios a los recursos** del sistema.
    
- Su objetivo es **evitar accesos indebidos** a memoria, archivos, dispositivos y procesos.
    
- Ejemplos:
    
    - Un proceso no puede modificar la memoria de otro proceso.
        
    - Archivos solo accesibles por ciertos usuarios o grupos.
        
- Implementaci√≥n t√≠pica:
    
    - **User IDs**: identificadores de usuario.
        
    - **Asociaci√≥n de permisos** con archivos y procesos.
        
    - **Grupos de usuarios**: permiten aplicar pol√≠ticas de acceso colectivas.
        

> _Referencia:_ Silberschatz, Galvin & Gagne, _Operating System Concepts_, Cap. 14.  
> _Referencia:_ Tanenbaum, _Modern Operating Systems_, Cap. 5.

---

### 2. **Seguridad**

- Es la **defensa del sistema contra ataques internos o externos**.
    
- Busca proteger al sistema de **usuarios maliciosos, virus, malware o intrusiones**.
    
- Incluye:
    
    - Autenticaci√≥n de usuarios.
        
    - Control de acceso a recursos.
        
    - Prevenci√≥n de intrusiones y auditor√≠a de actividades.
        
    - Encriptaci√≥n de informaci√≥n sensible.
        

> _Referencia:_ Silberschatz et al., Cap. 14.

---

### 3. **Distinci√≥n clave**

|Concepto|Objetivo|Ejemplos|
|---|---|---|
|Protecci√≥n|Evitar accesos indebidos de **usuarios y procesos leg√≠timos**|Permisos de lectura/escritura/ejecuci√≥n, bit de modo CPU, listas de control de acceso (ACL)|
|Seguridad|Evitar **ataques maliciosos** que comprometan el sistema|Firewalls, autenticaci√≥n, cifrado, detecci√≥n de intrusos|

---

üí° **Resumiendo en palabras simples**:

- **Protecci√≥n** ‚Üí ‚ÄúQue nadie acceda donde no debe‚Äù (interno).
    
- **Seguridad** ‚Üí ‚ÄúQue un ataque no rompa algo indebido‚Äù (externo o malicioso).
    

---

Sistemas operativos para clusters.
presento al usuario una unica computadora.
pero son varias pcs, en realidad.
DOS Distributes OS.


Sistemas de tiempo real: recibe input de un ambiente, y debe responder en parametros muy precisos de tiempo.

Perfecto, vamos a organizar estos conceptos usando referencias de **Tanenbaum** y **Silberschatz**:

---

## **1. Sistemas Operativos para Clusters**

Un **cluster** es un conjunto de computadoras independientes que trabajan juntas para **presentar al usuario la apariencia de una sola m√°quina**.

### Caracter√≠sticas:

- Los usuarios ven **una √∫nica interfaz**, aunque los procesos puedan ejecutarse en distintos nodos.
    
- Cada nodo tiene su **CPU, memoria y dispositivos**, pero el SO de cluster se encarga de **coordinar recursos y procesos**.
    
- Ventajas:
    
    - **Tolerancia a fallos**: si un nodo falla, otros nodos pueden continuar ejecutando los procesos.
        
    - **Paralelismo real**: m√∫ltiples procesos o threads pueden ejecutarse simult√°neamente en distintos nodos.
        
    - **Escalabilidad**: se pueden a√±adir m√°s nodos para aumentar capacidad.
        

### Tipos de sistemas de clusters:

1. **Sistemas distribuidos (Distributed OS)**
    
    - Coordinan procesos y recursos a trav√©s de la red.
        
    - Gestionan comunicaci√≥n, sincronizaci√≥n y acceso a memoria distribuida.
        
    - Ejemplos: **Amoeba, LOCUS, MOSIX**.
        

> _Referencia:_ Tanenbaum, _Modern Operating Systems_, Cap. 3.

---

## **2. Sistemas de Tiempo Real (Real-Time OS, RTOS)**

Un **sistema de tiempo real** es aquel que debe responder a eventos del entorno **dentro de l√≠mites de tiempo estrictos**.

### Caracter√≠sticas:

- Entrada de datos del **ambiente f√≠sico** (sensores, se√±ales).
    
- Salida debe ser generada en **tiempo predecible y garantizado**.
    
- Clasificaci√≥n:
    
    - **Hard real-time**: el incumplimiento del plazo puede causar fallo cr√≠tico.
        
    - **Soft real-time**: los plazos son deseables, pero no cr√≠ticos.
        
- Usos t√≠picos:
    
    - Control de maquinaria industrial.
        
    - Sistemas de aviaci√≥n o automoci√≥n.
        
    - Dispositivos m√©dicos cr√≠ticos.
        

> _Referencia:_ Silberschatz et al., _Operating System Concepts_, Cap. 1‚Äì2.  
> _Referencia:_ Tanenbaum, Cap. 5.

---

üí° **Resumiendo**:

- **Cluster OS** ‚Üí varias PCs funcionando como una sola, optimizando recursos y tolerancia a fallos.
    
- **RTOS** ‚Üí el SO debe garantizar **respuestas precisas en tiempo**, fundamental para entornos cr√≠ticos.
    

---

**Finalizado el documento de "clase 1".**