"Clase previa": [[Clase 1]]

Martes 12 de agosto de 2025 - Con Luis, es practica

* Verificaci√≥n de disco


varias pol√≠ticas:
preventivo, prentivo. variantes

quantum, eficiencia(midiendo el tiempo de servicio).

diagramas de gantt, tiempo de procesos, de fin.

hacer el integrador o morir.
entregable en modo ejecutable, o en docker.
planificaci√≥n, administraci√≥n de memoria, planificaci√≥n de disco.

m√©todos de acceso, organizaci√≥n de archivos.

---

[[Proceso]]
## **Definici√≥n de proceso**

Seg√∫n **Silberschatz, Galvin & Gagne** y **Tanenbaum**, un **proceso** es:

> ‚ÄúUn programa en ejecuci√≥n, junto con su estado actual y todos los recursos asociados que necesita para llevar a cabo su tarea.‚Äù

Un **programa** es un conjunto est√°tico de instrucciones almacenadas en alg√∫n medio.  
Un **proceso** es **din√°mico**: incluye la ejecuci√≥n actual del programa, los valores de variables, el contador de programa, los registros de CPU, las pilas y el espacio de memoria asignado.

---

### üîç **Componentes de un proceso**

En un modelo t√≠pico, un proceso contiene:

1. **C√≥digo** (_text segment_): instrucciones del programa.
    
2. **Datos est√°ticos** (_data segment_): variables globales y est√°ticas.
    
3. **Pila** (_stack_): variables locales, direcciones de retorno y control de llamadas a funciones.
    
4. **Mont√≠culo** (_heap_): memoria din√°mica solicitada en tiempo de ejecuci√≥n.
    
5. **Contexto de CPU**: valores de registros, contador de programa, banderas, etc.
    
6. **Recursos asociados**: archivos abiertos, dispositivos asignados, permisos, etc.
    

---

### üìå Relaci√≥n con paginaci√≥n

- En sistemas con **gesti√≥n de memoria por paginaci√≥n**, el espacio de direcciones de un proceso se divide en **p√°ginas** (unidades l√≥gicas) que se asignan a **marcos** (_frames_) de la memoria f√≠sica.
    
- Esto es **una t√©cnica de implementaci√≥n** de la memoria virtual, no parte esencial de la definici√≥n de proceso.
    
- El proceso ‚Äúse ve‚Äù como un bloque de memoria continua para el programador, pero internamente el SO lo maneja por p√°ginas o segmentos seg√∫n el esquema elegido.
    

---

üí° Resumen r√°pido para examen:

> Un **proceso** es un programa en ejecuci√≥n m√°s su estado y recursos asociados. Es la unidad b√°sica de trabajo del SO, que gestiona su ejecuci√≥n y memoria. En sistemas con memoria virtual, el espacio de direcciones del proceso puede dividirse en p√°ginas que el SO mapea a la memoria f√≠sica.

---
paginaci√≥n con segmentaci√≥n, combinaciones, tablas de paginas invertidas.
Memoria virtual, que es el concepto de swaping.

## **[[Paginaci√≥n y Segmentaci√≥n]]**
## üìö **1. Paginaci√≥n con segmentaci√≥n**

La paginaci√≥n y la segmentaci√≥n son dos t√©cnicas distintas de gesti√≥n de memoria.  
En **paginaci√≥n con segmentaci√≥n** se combinan para aprovechar ventajas de ambas:

- **Paginaci√≥n**: divide la memoria f√≠sica en marcos de tama√±o fijo, y la memoria l√≥gica en p√°ginas del mismo tama√±o.
    
- **Segmentaci√≥n**: divide el espacio l√≥gico en segmentos que representan unidades l√≥gicas de un programa (c√≥digo, datos, pila).
    

üí° **C√≥mo se combinan**

- Cada **segmento** se divide internamente en **p√°ginas**.
    
- Cada segmento tiene su **tabla de p√°ginas** correspondiente.
    
- La direcci√≥n l√≥gica se especifica como:
    
    ```
    (n√∫mero de segmento, n√∫mero de p√°gina, desplazamiento)
    ```
    
- El sistema usa la **tabla de segmentos** para localizar la **tabla de p√°ginas** correcta, y luego la tabla de p√°ginas para encontrar el marco f√≠sico.
    

**Ventajas**:

- Flexibilidad l√≥gica de segmentaci√≥n + control simple de fragmentaci√≥n de la paginaci√≥n.
    
- Permite protecci√≥n y compartici√≥n a nivel de segmento.
    

---

## üìö **2. Tablas de p√°ginas invertidas**

- En paginaci√≥n tradicional, cada proceso tiene su propia tabla de p√°ginas, lo que consume mucha memoria si el espacio de direcciones es grande.
    
- En una **tabla de p√°ginas invertida**, hay **una sola tabla global para todo el sistema**, con **una entrada por cada marco de memoria f√≠sica**, no por cada p√°gina l√≥gica.
    
- Cada entrada indica **qu√© p√°gina de qu√© proceso** est√° ocupando ese marco.
    
- Para traducir una direcci√≥n l√≥gica ‚Üí f√≠sica:
    
    1. Se busca en la tabla invertida (normalmente usando un _hash_) el marco que corresponde a `(id_proceso, num_p√°gina)`.
        
    2. Se obtiene el marco f√≠sico y se suma el desplazamiento.
        

**Ventajas**: ahorro de memoria en la tabla.  
**Desventaja**: traducci√≥n m√°s lenta, requiere b√∫squedas y TLB eficientes.

---

## üìö **3. Memoria virtual**

- **Concepto**: La memoria virtual es una abstracci√≥n que permite a un proceso tener un espacio de direcciones l√≥gico mucho mayor que la memoria f√≠sica real.
    
- Permite que los programas se carguen parcialmente en memoria y el resto permanezca en almacenamiento secundario, trayendo las partes necesarias bajo demanda.
    
- Se implementa mediante **paginaci√≥n bajo demanda** o **segmentaci√≥n bajo demanda**.
    

**Objetivos**:

1. Ejecutar programas m√°s grandes que la memoria f√≠sica.
    
2. Aislar procesos entre s√≠ (protecci√≥n).
    
3. Optimizar uso de memoria f√≠sica.
    

---

## üìö **4. Swapping**

- **Definici√≥n**: T√©cnica donde **un proceso completo** se copia temporalmente desde la memoria principal a almacenamiento secundario (por ejemplo, disco), para liberar memoria para otros procesos.
    
- Cuando el proceso necesita ejecutarse nuevamente, se trae de vuelta a memoria.
    
- Puede ocurrir:
    
    - **Total**: el proceso entero se mueve.
        
    - **Parcial**: solo algunas partes (p√°ginas o segmentos).
        
- El √°rea de disco usada para esto se llama **√°rea de swapping** o _swap space_.
    

**Diferencia clave con paginaci√≥n bajo demanda**:

- En _swapping_ tradicional se mueven bloques grandes (todo el proceso).
    
- En _paginaci√≥n bajo demanda_ solo se cargan p√°ginas necesarias.
    

---

üí° Si quer√©s, puedo prepararte un **diagrama unificado** con:

- Segmentaci√≥n con paginaci√≥n.
    
- Tabla de p√°ginas invertida.
    
- Ciclo de swapping.
    

---

memoria virtual, como funciona.
memoria de intercambio, porque se reserva? que es? que rol cumple?

Te lo explico con teor√≠a de **Sistemas Operativos** de **Silberschatz** y **Tanenbaum**, organizando por conceptos y con el porqu√© de cada uno.

---

## üìö **1. Memoria virtual ‚Äì c√≥mo funciona**

La **memoria virtual** es una t√©cnica que permite que los programas se ejecuten como si tuvieran disponible un espacio de direcciones grande y contiguo, aunque f√≠sicamente la memoria RAM sea limitada y no todo el programa est√© cargado al mismo tiempo.

**Funcionamiento b√°sico**:

1. **Abstracci√≥n**: cada proceso ve un espacio de direcciones l√≥gico propio (por ejemplo, 4 GB en un sistema de 32 bits).
    
2. **Traducci√≥n de direcciones**: el hardware de gesti√≥n de memoria (MMU) traduce direcciones l√≥gicas a direcciones f√≠sicas usando tablas de p√°ginas (o segmentos).
    
3. **Carga bajo demanda**: las partes del programa (p√°ginas o segmentos) se cargan a RAM solo cuando se necesitan (_demand paging_ o _demand segmentation_).
    
4. **Fallos de p√°gina**: si una p√°gina requerida no est√° en RAM, se produce un **page fault**. El SO pausa el proceso, trae la p√°gina desde almacenamiento secundario y luego contin√∫a la ejecuci√≥n.
    
5. **Reemplazo de p√°ginas**: si la RAM est√° llena, el SO elige una p√°gina para expulsar (_page replacement_), normalmente usando algoritmos como LRU, FIFO, Clock, etc.
    

**Ventajas**:

- Permite programas m√°s grandes que la memoria f√≠sica.
    
- Facilita multiprogramaci√≥n (varios procesos activos a la vez).
    
- A√≠sla procesos entre s√≠ (protecci√≥n).
    

---

## üìö **2. Memoria de intercambio (Swap Space)**

La **memoria de intercambio** o **√°rea de swap** es una zona reservada en un dispositivo de almacenamiento (generalmente un disco duro o SSD) que el sistema operativo utiliza para **almacenar temporalmente datos que no caben en la RAM**.

**¬øPor qu√© se reserva?**

- La RAM es limitada y costosa; el swap act√∫a como ‚Äúextensi√≥n‚Äù de la memoria f√≠sica.
    
- Al estar predefinida y separada de otras √°reas del disco, el SO puede acceder a ella de forma m√°s r√°pida y predecible que si usara espacio com√∫n del sistema de archivos.
    
- Garantiza que siempre habr√° un √°rea dedicada para volcar p√°ginas o procesos completos sin competir con otros usos del disco.
    

**¬øQu√© es exactamente?**

- Puede ser un **archivo especial** en el sistema de archivos o una **partici√≥n dedicada**.
    
- Contiene p√°ginas de procesos que han sido expulsadas de la RAM (_paged out_) o procesos enteros en sistemas con _swapping_ total.
    

**Rol en el sistema**:

1. **Almac√©n temporal** para p√°ginas expulsadas (memoria virtual).
    
2. **Permitir m√°s procesos simult√°neos** de lo que cabr√≠a solo en RAM.
    
3. **Soporte para hibernaci√≥n**: en algunos sistemas, el estado completo de la RAM se guarda en el √°rea de swap.
    

---

üí° Resumen de relaci√≥n:

- **Memoria virtual** ‚Üí T√©cnica general para dar a los procesos m√°s espacio del que f√≠sicamente existe, usando almacenamiento secundario como respaldo.
    
- **Memoria de intercambio (swap)** ‚Üí √Årea f√≠sica en disco reservada para guardar temporalmente partes de memoria que est√°n fuera de la RAM como parte de la implementaci√≥n de memoria virtual o _swapping_.
    

---


estados del proceso-
cache L1,L2,L3
 niveles de memoria.
 tama√±os de chache, que paginas metemos ahi y como lo manejamos?

Vamos por partes, como si fuera un apunte de examen de Sistemas Operativos + Arquitectura de Computadoras, siguiendo estructura de libro (**Tanenbaum**, **Silberschatz**, **Patterson & Hennessy**).

---

## üìö **1. Estados del Proceso**

Un proceso, mientras es gestionado por el SO, pasa por distintos **estados** que representan su situaci√≥n actual de ejecuci√≥n:

|Estado|Descripci√≥n|
|---|---|
|**Nuevo (New)**|El proceso est√° siendo creado, cargado en memoria y asignando recursos.|
|**Listo (Ready)**|Est√° en memoria principal, listo para ejecutar, esperando ser despachado por la CPU.|
|**En ejecuci√≥n (Running)**|Est√° usando la CPU en ese momento.|
|**Bloqueado/Esperando (Waiting/Blocked)**|Espera un evento externo (por ejemplo, finalizaci√≥n de E/S).|
|**Terminado (Terminated)**|El proceso ha finalizado su ejecuci√≥n y sus recursos ser√°n liberados.|
|_(Opcional)_ **Suspendido (Suspended)**|El proceso est√° en memoria secundaria (swap), temporalmente detenido por el SO o el usuario.|

üîç **Nota**: La transici√≥n entre estos estados se maneja mediante **planificaci√≥n** (scheduling) y **cambio de contexto** (context switch).

---

## üìö **2. Cach√© L1, L2, L3 ‚Äì Niveles de memoria**

En la jerarqu√≠a de memoria, las **cach√©s** son memorias r√°pidas, peque√±as y costosas ubicadas cerca de la CPU para reducir la latencia de acceso a datos e instrucciones.

- **L1**:
    
    - Integrada en el n√∫cleo del procesador.
        
    - M√°s r√°pida y peque√±a (generalmente 16 KB ‚Äì 128 KB por n√∫cleo).
        
    - Puede estar dividida en **L1 de datos (D-cache)** y **L1 de instrucciones (I-cache)**.
        
- **L2**:
    
    - M√°s grande (256 KB ‚Äì 2 MB), m√°s lenta que L1 pero m√°s r√°pida que RAM.
        
    - Puede estar dedicada por n√∫cleo o compartida entre pocos n√∫cleos.
        
- **L3**:
    
    - M√°s grande (4 MB ‚Äì 64 MB), m√°s lenta que L2 pero m√°s r√°pida que RAM.
        
    - Normalmente compartida entre todos los n√∫cleos de un procesador.
        

---

## üìö **3. Niveles de memoria (Jerarqu√≠a)**

De arriba (m√°s r√°pida y cara) a abajo (m√°s lenta y barata):

1. **Registros** ‚Äì Nanosegundos ‚Äì Bytes.
    
2. **Cach√© L1** ‚Äì Nanosegundos ‚Äì KB.
    
3. **Cach√© L2** ‚Äì Nanosegundos ‚Äì MB.
    
4. **Cach√© L3** ‚Äì Nanosegundos/microsegundos ‚Äì MB.
    
5. **RAM** ‚Äì Decenas de nanosegundos ‚Äì GB.
    
6. **Swap / SSD / HDD** ‚Äì Microsegundos a milisegundos ‚Äì GB/TB.
    
7. **Almacenamiento terciario** (cintas, √≥ptico) ‚Äì Milisegundos/segundos ‚Äì TB+.
    

---

## üìö **4. Tama√±os de cach√©, qu√© ‚Äúp√°ginas‚Äù metemos y c√≥mo se maneja**

### **Tama√±os t√≠picos** (aproximados, dependen de CPU):

- **L1**: 16‚Äì128 KB por n√∫cleo.
    
- **L2**: 256 KB ‚Äì 2 MB por n√∫cleo.
    
- **L3**: 4‚Äì64 MB compartidos.
    

### **Qu√© ‚Äúmetemos‚Äù en cach√©**:

- En realidad no se guardan p√°ginas enteras del sistema operativo, sino **l√≠neas de cach√©** (cache lines), que suelen medir 32‚Äì128 bytes.
    
- Estas l√≠neas contienen datos o instrucciones que la CPU predice que necesitar√° pronto, seg√∫n:
    
    - **Localidad temporal**: reutilizar datos usados recientemente.
        
    - **Localidad espacial**: acceder a datos cercanos a los ya usados.
        

### **C√≥mo se maneja**:

- **Mapeo**: directo, asociativo por conjunto o totalmente asociativo.
    
- **Pol√≠tica de reemplazo**: normalmente _LRU_ (Least Recently Used) o variantes.
    
- **Pol√≠tica de escritura**: _write-through_ (escribir en RAM y cach√©) o _write-back_ (escribir solo en cach√© y pasar a RAM cuando se expulsa la l√≠nea).
    

---

üí° Resumen clave para examen:

> Estados de proceso ‚Üí describe su ciclo de vida.  
> Cach√© L1/L2/L3 ‚Üí son memorias intermedias cada vez m√°s grandes y lentas.  
> Jerarqu√≠a de memoria ‚Üí organiza velocidad, costo y capacidad.  
> Cach√© almacena **l√≠neas**, no p√°ginas enteras, y usa pol√≠ticas de reemplazo/escritura para optimizar rendimiento.

---

Si quer√©s, te puedo armar un **esquema gr√°fico √∫nico** con:

- Estados de proceso.
    
- Jerarqu√≠a de memoria.
    
- Flujo de datos de cach√© y RAM.  


---
discos:
indexada, secuenciada, como va a parar al disco, y pol√≠ticas de disco.
tiempos de acceso, atenci√≥n de requerimientos de bloque, 

Te lo organizo con teor√≠a de **Sistemas Operativos** (Silberschatz, Tanenbaum) y un poco de **Organizaci√≥n de Computadoras** para la parte f√≠sica.

---

## üìö **1. M√©todos de acceso a disco**

Cuando hablamos de _indexada_ y _secuencial_, nos referimos a **c√≥mo est√°n organizados los archivos y c√≥mo se localizan sus bloques**.

### **a) Acceso secuencial**

- Los datos se almacenan en bloques uno tras otro.
    
- Para acceder a un bloque intermedio, se deben leer los anteriores (o conocer la posici√≥n exacta).
    
- Ejemplo: cintas magn√©ticas o ficheros de texto lineales.
    
- Ventaja: simple y eficiente para lecturas completas.
    
- Desventaja: lento para acceso aleatorio.
    

### **b) Acceso indexado**

- Existe una **tabla de √≠ndices** (como una tabla de p√°ginas pero para archivos) que almacena las direcciones de cada bloque de datos.
    
- Permite **acceso directo** a cualquier bloque.
    
- Ejemplo: sistema de archivos UNIX con **i-nodos**.
    
- Ventaja: r√°pido para saltar a datos espec√≠ficos.
    
- Desventaja: requiere espacio extra para el √≠ndice.
    

üí° En discos modernos, incluso un acceso ‚Äúsecuencial‚Äù a nivel l√≥gico termina siendo traducido por el **sistema de archivos** y el **controlador de disco** a accesos f√≠sicos optimizados.

---

## üìö **2. C√≥mo ‚Äúva a parar‚Äù la informaci√≥n al disco**

1. **Aplicaci√≥n** pide leer/escribir datos.
    
2. **Sistema de archivos** traduce la solicitud a bloques l√≥gicos.
    
3. **Gestor de E/S del SO** convierte esos bloques l√≥gicos en direcciones f√≠sicas (cilindro, pista, sector) usando la **estructura del disco**.
    
4. **Controlador de disco** recibe la orden y mueve el brazo (si es HDD) o direcciona la celda (si es SSD).
    
5. Datos pasan por el **buffer del controlador** y luego por el **bus** hasta la RAM.
    

---

## üìö **3. Pol√≠ticas de planificaci√≥n de disco**

Objetivo: minimizar el **tiempo medio de acceso**.

- **FCFS (First Come, First Served)**: atiende en el orden de llegada. Justo, pero no optimiza movimientos.
    
- **SSTF (Shortest Seek Time First)**: elige la petici√≥n m√°s cercana a la posici√≥n actual del cabezal. Minimiza b√∫squeda pero puede provocar inanici√≥n (_starvation_).
    
- **SCAN (Elevator)**: el cabezal se mueve en una direcci√≥n atendiendo todas las solicitudes en el camino, luego invierte direcci√≥n.
    
- **C-SCAN (Circular SCAN)**: como SCAN, pero al llegar al extremo, vuelve directamente al inicio sin atender en el regreso.
    
- **LOOK / C-LOOK**: variantes de SCAN/C-SCAN que paran en la √∫ltima petici√≥n en vez de ir hasta el borde del disco.
    

---

## üìö **4. Tiempos de acceso al disco (HDD)**

Tiempo total de acceso (**TA**) ‚âà **Tb√∫squeda + Trotaci√≥n + Ttransferencia**.

1. **Tiempo de b√∫squeda** (_seek time_):  
    Tiempo para mover el brazo al cilindro deseado. T√≠pico: 2‚Äì10 ms.
    
2. **Latencia rotacional**:  
    Tiempo de espera para que el sector deseado pase bajo el cabezal. Promedio ‚âà ¬Ω revoluci√≥n. T√≠pico: 2‚Äì6 ms.
    
3. **Tiempo de transferencia**:  
    Tiempo para leer/escribir los bits del sector. Depende de la velocidad de rotaci√≥n y el tama√±o del sector.
    

---

## üìö **5. Atenci√≥n de requerimientos de bloque**

- **Cola de solicitudes**: el SO mantiene una lista de peticiones pendientes.
    
- **Planificador de disco**: decide el orden en que se procesar√°n (seg√∫n pol√≠tica elegida).
    
- **Despachador**: env√≠a la orden al controlador del disco.
    
- **Gesti√≥n de buffer**: puede usar _read-ahead_ (leer bloques contiguos anticipadamente) y _write-back_ (acumular escrituras antes de hacerlas).
    

---

üí° Resumen r√°pido:

> - **Secuencial**: bloques uno tras otro, acceso lineal.
>     
> - **Indexada**: tabla de direcciones ‚Üí acceso aleatorio.
>     
> - **Tiempo de acceso**: b√∫squeda + rotaci√≥n + transferencia.
>     
> - **Pol√≠ticas de disco**: FCFS, SSTF, SCAN, C-SCAN, LOOK.
>     
> - El SO traduce de bloques l√≥gicos a f√≠sicos y optimiza el orden para minimizar movimientos.
>     

---



el trabajo 
Procesos, memoria y discos.

jueves de 6 a 8

Siguiente Clase: [[Clase 3]]


